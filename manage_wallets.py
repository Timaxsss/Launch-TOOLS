import asyncio
import base58
import csv
from solana.rpc.async_api import AsyncClient
from solders.keypair import Keypair
from solders.pubkey import Pubkey
from solders.message import MessageV0
from solders.system_program import TransferParams, transfer
from solders.transaction import VersionedTransaction

async def send_sol_multi(sender_private_key: str, csv_file: str, amount_sol: float, mode: str):
    client = AsyncClient("your_rpc_endpoint")
    sender = Keypair.from_bytes(base58.b58decode(sender_private_key))
    lamports = int(amount_sol * 10**9)

    # Read data from the CSV file
    print(f"Performing {mode} operation on wallets listed in {csv_file} generated by gen_wallets.py")
    with open(csv_file, mode='r') as file:
        csv_reader = csv.DictReader(file)

        if mode == "fund":
            receivers = [row['WALLET'] for row in csv_reader]
            for receiver_address in receivers:
                await transfer_sol(sender, receiver_address, lamports, client)
            print(f"Successfully funded all wallets from {csv_file}.")

        elif mode == "refund":
            for row in csv_reader:
                receiver_address = sender.pubkey()  # Funds returned to the sender's address
                wallet_address = row['WALLET']
                wallet_private_key = row['PRIVATE KEY']
                keypair = Keypair.from_bytes(base58.b58decode(wallet_private_key))

                # Retrieve the wallet balance
                balance = (await client.get_balance(Pubkey.from_string(wallet_address))).value
                
                # Ensure the wallet covers the transaction fees
                min_balance_required = 5000  # Reserve for transaction fees
                
                if balance > min_balance_required:
                    # Calculate the refund amount, taking fees into account
                    refund_amount = balance - min_balance_required
                    print(f"Refunding {refund_amount} lamports from {wallet_address} to {sender.pubkey()}")
                    await transfer_sol(keypair, str(receiver_address), refund_amount, client)
                else:
                    print(f"The balance of {wallet_address} is insufficient to cover transaction fees.")
            print(f"Successfully refunded all eligible wallets from {csv_file}.")
        
        elif mode == "balance":
            for row in csv_reader:
                wallet_address = row['WALLET']
                balance_lamports = (await client.get_balance(Pubkey.from_string(wallet_address))).value
                balance_sol = balance_lamports / 10**9  # Convert lamports to SOL
                print(f"Wallet: {wallet_address}, Balance: {balance_sol:.9f} SOL")  # Display in SOL with 9 decimal places

    await client.close()

async def transfer_sol(sender, receiver_address, lamports, client):
    max_retries = 5
    for attempt in range(max_retries):
        try:
            # Ensure receiver_address is correctly processed
            receiver = Pubkey.from_string(receiver_address) if isinstance(receiver_address, str) else receiver_address
            blockhash = (await client.get_latest_blockhash()).value.blockhash
            ix = transfer(TransferParams(from_pubkey=sender.pubkey(), to_pubkey=receiver, lamports=lamports))
            msg = MessageV0.try_compile(
                payer=sender.pubkey(),
                instructions=[ix],
                address_lookup_table_accounts=[],
                recent_blockhash=blockhash,
            )
            tx = VersionedTransaction(msg, [sender])
            result = await client.send_transaction(tx)
            await client.confirm_transaction(result.value)
            print(f"Transaction sent to {receiver_address}: {result.value}")
            break
        except Exception as e:
            if attempt == max_retries - 1:
                print(f"Transaction failed for {receiver_address} after {max_retries} attempts")
            else:
                print(f"Error: {e}. Attempt {attempt+1}/{max_retries}")

# Determine if we're performing a 'fund', 'refund', or 'balance'
mode = input("Choose an option ('fund' to send, 'refund' to recover, 'balance' to check balances): ").strip().lower()

# Call the function with the private key and the CSV file
asyncio.run(send_sol_multi(
    sender_private_key="your_priv_key",
    csv_file='wallets.csv',
    amount_sol=0.001,  # Amount of SOL to send (only used for 'fund')
    mode=mode
))
